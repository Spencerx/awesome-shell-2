#!/usr/bin/env bash

file="${BASH_SOURCE[0]:-$0}"
start_working_dir=$(pwd)
while [ -h "$file" ]; do # while source is a symlink
    dir="$( cd -P "$( dirname "$file" )" && pwd )"
    file="$(readlink "$file")"
    [[ "$file" != /* ]] && file="$dir/$file" # complete dir path for relative symlinks
done
dir="$( cd -P "$( dirname "$file" )" && pwd )"
shebang_name=$(basename "$file")

fatal(){
    echo "‚ùå  Fatal error: $*"
    exit 1
}

destination_file=""
# To track requested revision:
ref=""
verbose=0
while [ $# -gt 0 ]
do
    opt="$1"
    [ -f "$opt" ] && destination_file="$opt" && break
    shift
    case $opt in
        --ref)
        [ -z "$1" ] && fatal "--ref option requires a SHA1 value of desired awesome-shell repo commit to use"
        grep -q -e '^[0-9a-f]\{5,40\}$' <<< "$1" || fatal "--ref option value does not appear to have valid SHA1 format"
        ref="$1"
        shift
        ;;
        --verbose)
        verbose=1
        ;;
        --version)
            ver=$(cd "$dir" && git log --date=short --format='awesome-shell repo %n version: %h (%ad) %n  author: %an' -1)
            [ $? -eq 0 ] || fatal "Failed to get version information from git"
            echo "$shebang_name is a part of $ver"
            exit 0
        ;;
        --update)
            cd "$dir" && git pull --quiet --rebase origin master >> /dev/null
            [ $? -eq 0 ] || fatal "Failed to pull updates from git origin"
            exit 0
    esac
done


# Check if revision was specified in the file body [old way; deprecated]:
if [ -z "$ref" ] && [ -f "$destination_file" ];then
 ref_line=$(grep -m1 --color=never -o "^#awesome-shell ref:[0-9a-f]*$" "$destination_file")
 [ "${ref_line:0:1}" = "#" ] && ref=$(echo "$ref_line" | cut -d':' -f2)
 if [ -n "$ref" ];then
     # perform a rewrite to use new style:
     rewrite=$(sed -e "1 s/$shebang_name/$shebang_name --ref $ref/1" -e '/#awesome-shell ref:/d' "$destination_file")
     echo "$rewrite" > "$destination_file"
 fi;
fi;


if [ -n "$ref" ]; then
    [ $verbose -eq 1 ] && echo "Will use awesome-shell commit '$ref'"
    cd "$dir" 1>/dev/null 2>&1 || fatal "Cannot cd into '$dir'"
    retries_remaining=2
    awesome_shell_commit_ref=""
    while [[ $retries_remaining -gt 0 ]];do
        retries_remaining=$((retries_remaining -1))
        if [ "$(git cat-file -t "$ref" 2>/dev/null)" = "commit" ];then
            awesome_shell_commit_ref="$ref";
        else
            git fetch origin 1>/dev/null 2>&1
            if [ $? -ne 0 ];then
                echo "Cannot fetch updates for awesome-shell";
                retries_remaining=0;
            fi;
        fi;
    done;
    [ -z "$awesome_shell_commit_ref" ] && fatal "Cannot find requested '$ref' commit in awesome-shell repo";
fi;


if [ -n "$awesome_shell_commit_ref" ];then
    commons_content=$(git show "$awesome_shell_commit_ref:commons") || fatal "Cannot find commons in '$awesome_shell_commit_ref'"
    awesome_shell_commons_file_dir="$dir"
    eval "$commons_content"
elif [ -x "$dir/commons" ]; then
    source "$dir/commons"
else
    fatal "Cannot init awesome-shell commons"
fi

if [ -f "$destination_file" ]; then
    awesome_shell_script_path="$destination_file"
    awesome_shell_script_name=$(basename "$destination_file")
    if [ -d "$start_working_dir" ];then
        cd "$start_working_dir" || fatal "awesome-shell cannot cd to starting working directory"
    fi;
    shift # so that the name of the script in no longer in $1 position
    awesome_shell_arguments=("${@:1}")
    script=$(cat "$awesome_shell_script_path")
    if [[ "$script" == *awesome_shell_help* ]];then
        awesome_shell_include help
    fi;
    eval "$script"
fi
